

## 배열  

### 배열의 개념  

- 배열은 인덱스와 원소값의 쌍(`<index, value>`)으로 구성된 집합이다.  
- 배열의 원소(인덱스와 원소값으 쌍)는 모두 같은 자료형이다.  
- 배열의 원소는 모두 같은 크기의 기억 공간(메모리 크기) 를 갖는다.  
- 배열의 원소들은 인덱스로 표현되는 순서를 가진다.  
- 배열의 원소 간 논리적인 순서가 각 원소의 물리적인 위치(메모리 주소)의 순서와 일치한다.  

### 배열의 인덱스값과 메모리 주소의 관계  

**요약**  

- 배열의 인덱스는 실제 메모리 주소값을 추상화한 값이다.  
- 배열 내의 원소간 순서는 각 원소가 저장된 메모리 주소값 간의 순서와 동일하다.  

![](/assets/images/20241202_003_001.png)  

배열의 인덱스는 배열 내 값(value)의 위치를 나타내는 숫자이다. 다만 인덱스는 실제 물리적인 위치값(주소값)을 나타내는 것은 아닌 배열 내 요소의 상대적인 순서를 나타내는 논리적인 위치값이다. 이러한 상대적인 순서는 배열의 각 요소가 저장된 메모리의 주소값 간에도 동일한 순서로 적용된다.  

배열의 인덱스는 0부터 시작해 순차적으로 1씩 증가하는 10진수 형태이며, 실제 메모리의 주소값은 16진수의 형태를 가지고 있다. 때문에 둘은 직접적으로 매칭이 될 수는 없으며, 이 둘 사이에서 프로그래밍 언어와 운영체제가 각각 배열의 순서와 실제 메모리의 주소값을 번역하고 매칭시켜 관리한다.  

운영체제는 프로세스가 사용할 수 있는 메모리 영역을 관리하고 할당하는데, 가상 메모리를 실제 물리적 메모리에 매핑하는 역할을 담당한다. 프로그래밍 언어와 컴파일러(혹은 인터프리터)는 배열의 기초 주소(base address), 요소의 크기(size), 인덱스를 기반으로 가상 메모리의 주소를 계산한다. 이 두 가지가 결합되어 배열의 인덱스를 사용한 논리적인 위치 접근과 실제 메모리의 물리적 위치 간의 연결을 제공한다.  

결론적으로 배열의 인덱스는 실제 메모리 주소값을 추상화한 값이며, 배열 내의 원소간 순서는, 배열의 각 원소가 저장된 메모리 주소값 간의 순서와 동일하다는 특징을 가지고 있다.  


## 배열의 추상 자료형과 배열 연산의 구현  

### 배열의 추상 자료형  

```c
ADT Array

1. 정의
- <i ∈ Index, e ∈ Element> 쌍들의 집합
- Index : 순서를 나타내는 원소의 유한집합
- Element : 자료형이 동일한 원소의 집합

2. 연산
- a : 0개 이상의 원소를 갖는 배열
- e : 배열에 저장되는 원소
- n : 배열의 최대 크기를 정의하는 정수값
- a ∈ Array; i ∈ Index; e ∈ Element, n ∈ Integer 라고 할 때
- a, item, n에 대해 다음과 같은 연산이 정의된다.  

(1) Array create(n) ::= 배열의 크기가 n인 배열을 생성하고, 공백 배열을 반환한다. // 생성 연산

(2) Element retrieve(a, i) ::= if(i ∈ Index) // 검색 연산
        then { 배열의 i 번째에 해당하는 원소값 e를 반환한다; }
        else { 에러 메시지를 반환한다; }

(3) Array store(a, i, e) ::= if(i ∈ Index) // 저장 연산
        then { 배열 a의 i 번째 위치에 원소값 e를 저장하고 배열 a를 반환한다;}
        else { 인덱스 i가 배열 a의 크기를 벗어나면 에러 메시지를 반환한다;}

End Array
```

### 배열 연산의 구현  

**(1)배열의 생성**  

```c
void create(int n) {
    int a[n];
    int i;
    for(i=0, i<n, i++){
        a[i] = 0;
    }
}
```

**(2)배열값의 검색(retrieve)**  

```c
int retrieve(int *a, int i) {
    if (i >=0 && i < array_size)
        return a[i];
    else {printf("Error₩n");
        return (-1);    }
}
```

**(3)배열값의 저장(store)**  

```c
void store(int *a, int i, int e) {
    if (i >= 0 && i < array_size)
        a[i] = e;
    else printf("Error₩n");
}
```

## 실제로 배열을 살펴보기  

### 1차원 배열  

**(1) 1차원 배열의 정의**  

1차원 배열이란, 한 줄짜리 배열을 의미한다. 따라서 하나의 인덱스로 구분된다. (`a[1]` 과 같이)


**(2) 1차원 배열에서의 주소 계산**  


### 배열의 확장

**(1) 2차원 배열(행렬)의 표현**  


**(2) 행우선 배열**  


**(4) 열우선 배열**  


### 행우선 할당과 열우선 할당  

**(3) 행우선 할당**  

**(5) 열우선 할당**  



### 희소행렬의 표현  

